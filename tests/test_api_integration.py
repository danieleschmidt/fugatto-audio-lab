"""Integration tests for Fugatto Audio Lab API."""

import pytest
import json
import io
import tempfile
from pathlib import Path
from unittest.mock import Mock, patch, AsyncMock
import numpy as np

try:
    from fastapi.testclient import TestClient
    from fastapi import FastAPI
    FASTAPI_AVAILABLE = True
except ImportError:
    FASTAPI_AVAILABLE = False
    TestClient = None
    FastAPI = None

if FASTAPI_AVAILABLE:
    from fugatto_lab.api.routes.audio import router as audio_router
    from fugatto_lab.api.app import create_app


@pytest.mark.skipif(not FASTAPI_AVAILABLE, reason="FastAPI not available")
class TestAudioAPIIntegration:
    """Integration tests for audio API endpoints."""
    
    @pytest.fixture
    def app(self):
        """Create test FastAPI application."""
        app = FastAPI(title="Test Fugatto API")
        app.include_router(audio_router)
        return app
    
    @pytest.fixture
    def client(self, app):
        """Create test client."""
        return TestClient(app)
    
    @pytest.fixture
    def mock_audio_data(self):
        """Mock audio data for testing."""
        # Generate 1 second of sine wave at 440Hz, 48kHz sample rate
        sample_rate = 48000
        t = np.linspace(0, 1, sample_rate)
        audio = np.sin(2 * np.pi * 440 * t).astype(np.float32)
        return audio
    
    @pytest.fixture
    def mock_audio_file(self, mock_audio_data):
        """Create mock audio file for upload tests."""
        # Create a temporary WAV file
        with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as temp_file:\n            # Write minimal WAV header and data\n            # This is a simplified WAV format for testing\n            import struct\n            import wave\n            \n            # Convert audio data to 16-bit integers\n            audio_16bit = (mock_audio_data * 32767).astype(np.int16)\n            \n            # Write WAV file\n            with wave.open(temp_file.name, 'wb') as wav_file:\n                wav_file.setnchannels(1)  # Mono\n                wav_file.setsampwidth(2)  # 16-bit\n                wav_file.setframerate(48000)  # 48kHz\n                wav_file.writeframes(audio_16bit.tobytes())\n            \n            return temp_file.name\n    \n    def test_generate_audio_endpoint(self, client):\n        \"\"\"Test audio generation endpoint.\"\"\"\n        with patch('fugatto_lab.api.routes.audio.get_audio_generation_service') as mock_service_dep:\n            # Mock the service\n            mock_service = Mock()\n            mock_service.generate_audio.return_value = {\n                'generated_audio': np.random.randn(48000).astype(np.float32),\n                'duration_seconds': 10.0,\n                'sample_rate': 48000,\n                'audio_stats': {'rms': 0.5, 'peak': 0.8}\n            }\n            mock_service_dep.return_value = mock_service\n            \n            # Mock other dependencies\n            with patch('fugatto_lab.api.routes.audio.get_audio_repository') as mock_repo_dep:\n                mock_repo = Mock()\n                mock_repo_dep.return_value = mock_repo\n                \n                with patch('fugatto_lab.api.routes.audio.AudioProcessor') as mock_processor:\n                    mock_processor_instance = Mock()\n                    mock_processor.return_value = mock_processor_instance\n                    \n                    # Test request\n                    request_data = {\n                        \"prompt\": \"A cat meowing softly\",\n                        \"duration_seconds\": 10.0,\n                        \"temperature\": 0.8,\n                        \"save_output\": False  # Don't save for test\n                    }\n                    \n                    response = client.post(\"/audio/generate\", json=request_data)\n                    \n                    assert response.status_code == 200\n                    data = response.json()\n                    \n                    # Check response structure\n                    assert \"task_id\" in data\n                    assert \"duration_seconds\" in data\n                    assert \"generation_time_ms\" in data\n                    assert \"status\" in data\n                    assert data[\"status\"] == \"completed\"\n                    assert data[\"duration_seconds\"] == 10.0\n                    \n                    # Verify service was called\n                    mock_service.generate_audio.assert_called_once()\n    \n    def test_generate_audio_validation(self, client):\n        \"\"\"Test input validation for audio generation.\"\"\"\n        # Test empty prompt\n        response = client.post(\"/audio/generate\", json={\"prompt\": \"\"})\n        assert response.status_code == 422\n        \n        # Test invalid duration\n        response = client.post(\"/audio/generate\", json={\n            \"prompt\": \"Test\",\n            \"duration_seconds\": -1\n        })\n        assert response.status_code == 422\n        \n        # Test duration too long\n        response = client.post(\"/audio/generate\", json={\n            \"prompt\": \"Test\",\n            \"duration_seconds\": 100\n        })\n        assert response.status_code == 422\n        \n        # Test invalid temperature\n        response = client.post(\"/audio/generate\", json={\n            \"prompt\": \"Test\",\n            \"temperature\": 2.0\n        })\n        assert response.status_code == 422\n    \n    def test_transform_audio_endpoint(self, client, mock_audio_file):\n        \"\"\"Test audio transformation endpoint.\"\"\"\n        with patch('fugatto_lab.api.routes.audio.get_audio_generation_service') as mock_service_dep:\n            # Mock the service\n            mock_service = Mock()\n            mock_service.transform_audio.return_value = {\n                'transformed_audio': np.random.randn(48000).astype(np.float32),\n                'duration_seconds': 1.0,\n                'audio_stats': {'rms': 0.6, 'peak': 0.9}\n            }\n            mock_service_dep.return_value = mock_service\n            \n            with patch('fugatto_lab.api.routes.audio.get_audio_processor') as mock_proc_dep:\n                mock_processor = Mock()\n                mock_processor.load_audio.return_value = np.random.randn(48000).astype(np.float32)\n                mock_proc_dep.return_value = mock_processor\n                \n                # Prepare file upload\n                with open(mock_audio_file, 'rb') as f:\n                    files = {'audio_file': ('test.wav', f, 'audio/wav')}\n                    data = {\n                        'prompt': 'Add reverb effect',\n                        'strength': 0.7,\n                        'preserve_length': True\n                    }\n                    \n                    response = client.post(\"/audio/transform\", files=files, data=data)\n                    \n                    assert response.status_code == 200\n                    result = response.json()\n                    \n                    # Check response structure\n                    assert \"task_id\" in result\n                    assert \"input_filename\" in result\n                    assert \"transformation_prompt\" in result\n                    assert \"strength\" in result\n                    assert result[\"transformation_prompt\"] == \"Add reverb effect\"\n                    assert result[\"strength\"] == 0.7\n                    \n                    # Verify service was called\n                    mock_service.transform_audio.assert_called_once()\n    \n    def test_clone_voice_endpoint(self, client, mock_audio_file):\n        \"\"\"Test voice cloning endpoint.\"\"\"\n        with patch('fugatto_lab.api.routes.audio.get_voice_clone_service') as mock_service_dep:\n            # Mock the service\n            mock_service = Mock()\n            mock_service.clone_voice.return_value = {\n                'cloned_audio': np.random.randn(48000).astype(np.float32),\n                'duration_seconds': 3.0,\n                'speaker_id': 'test_speaker',\n                'audio_stats': {'rms': 0.4, 'peak': 0.7}\n            }\n            mock_service_dep.return_value = mock_service\n            \n            with patch('fugatto_lab.api.routes.audio.get_audio_processor') as mock_proc_dep:\n                mock_processor = Mock()\n                mock_proc_dep.return_value = mock_processor\n                \n                # Prepare file upload\n                with open(mock_audio_file, 'rb') as f:\n                    files = {'reference_audio': ('reference.wav', f, 'audio/wav')}\n                    data = {\n                        'text': 'Hello, this is a test of voice cloning',\n                        'speaker_id': 'test_speaker',\n                        'prosody_transfer': True\n                    }\n                    \n                    response = client.post(\"/audio/clone\", files=files, data=data)\n                    \n                    assert response.status_code == 200\n                    result = response.json()\n                    \n                    # Check response structure\n                    assert \"task_id\" in result\n                    assert \"synthesized_text\" in result\n                    assert \"speaker_id\" in result\n                    assert result[\"synthesized_text\"] == data['text']\n                    assert result[\"prosody_transfer\"] == True\n                    \n                    # Verify service was called\n                    mock_service.clone_voice.assert_called_once()\n    \n    def test_analyze_audio_endpoint(self, client, mock_audio_file):\n        \"\"\"Test audio analysis endpoint.\"\"\"\n        with patch('fugatto_lab.api.routes.audio.get_audio_analyzer') as mock_analyzer_dep:\n            # Mock the analyzer\n            mock_analyzer = Mock()\n            mock_analyzer.analyze_comprehensive.return_value = {\n                'basic': {'duration': 1.0, 'rms': 0.5, 'peak': 0.8},\n                'spectral': {'centroid_mean': 1000.0, 'rolloff_mean': 2000.0},\n                'temporal': {'zcr_mean': 0.1, 'tempo': 120.0}\n            }\n            mock_analyzer_dep.return_value = mock_analyzer\n            \n            with patch('fugatto_lab.api.routes.audio.get_audio_processor') as mock_proc_dep:\n                mock_processor = Mock()\n                mock_processor.load_audio.return_value = np.random.randn(48000).astype(np.float32)\n                mock_processor.analyze_audio_quality.return_value = {\n                    'snr_db': 20.0,\n                    'thd': 0.01,\n                    'clipping_ratio': 0.0\n                }\n                mock_processor.get_audio_stats.return_value = {\n                    'duration_seconds': 1.0,\n                    'sample_rate': 48000\n                }\n                mock_proc_dep.return_value = mock_processor\n                \n                # Prepare file upload\n                with open(mock_audio_file, 'rb') as f:\n                    files = {'audio_file': ('analyze.wav', f, 'audio/wav')}\n                    data = {\n                        'include_features': ['basic', 'spectral'],\n                        'detailed_analysis': True\n                    }\n                    \n                    response = client.post(\"/audio/analyze\", files=files, data=data)\n                    \n                    assert response.status_code == 200\n                    result = response.json()\n                    \n                    # Check response structure\n                    assert \"task_id\" in result\n                    assert \"analysis_results\" in result\n                    assert \"analysis_time_ms\" in result\n                    assert \"audio_stats\" in result\n                    \n                    # Check analysis results\n                    analysis = result[\"analysis_results\"]\n                    assert \"basic\" in analysis\n                    assert \"spectral\" in analysis\n                    assert \"quality\" in analysis\n                    \n                    # Verify analyzer was called\n                    mock_analyzer.analyze_comprehensive.assert_called_once()\n    \n    def test_batch_processing_endpoint(self, client):\n        \"\"\"Test batch processing endpoint.\"\"\"\n        request_data = {\n            \"operation\": \"generate\",\n            \"parameters\": {\n                \"prompts\": [\n                    \"A dog barking\",\n                    \"Rain falling on leaves\",\n                    \"Piano melody\"\n                ],\n                \"duration_seconds\": 5.0,\n                \"temperature\": 0.8\n            },\n            \"parallel_workers\": 2,\n            \"save_individual\": True,\n            \"create_manifest\": True\n        }\n        \n        response = client.post(\"/audio/batch\", json=request_data)\n        \n        assert response.status_code == 200\n        result = response.json()\n        \n        # Check response structure\n        assert \"batch_id\" in result\n        assert \"operation\" in result\n        assert \"status\" in result\n        assert result[\"operation\"] == \"generate\"\n        assert result[\"status\"] == \"initializing\"\n        \n        # Test getting batch status\n        batch_id = result[\"batch_id\"]\n        status_response = client.get(f\"/audio/batch/{batch_id}\")\n        \n        assert status_response.status_code == 200\n        status_result = status_response.json()\n        assert status_result[\"batch_id\"] == batch_id\n    \n    def test_list_audio_records_endpoint(self, client):\n        \"\"\"Test listing audio records endpoint.\"\"\"\n        with patch('fugatto_lab.api.routes.audio.get_audio_repository') as mock_repo_dep:\n            # Mock the repository\n            mock_repo = Mock()\n            \n            # Create mock records\n            from fugatto_lab.database.models import AudioRecordData\n            from datetime import datetime\n            \n            mock_records = [\n                AudioRecordData(\n                    id=1,\n                    prompt=\"Test prompt 1\",\n                    audio_path=\"/path/to/audio1.wav\",\n                    duration_seconds=10.0,\n                    sample_rate=48000,\n                    model_name=\"nvidia/fugatto-base\",\n                    temperature=0.8,\n                    generation_time_ms=1500.0,\n                    metadata={},\n                    tags=[\"test\"],\n                    created_at=datetime.now()\n                ),\n                AudioRecordData(\n                    id=2,\n                    prompt=\"Test prompt 2\",\n                    audio_path=\"/path/to/audio2.wav\",\n                    duration_seconds=15.0,\n                    sample_rate=48000,\n                    model_name=\"nvidia/fugatto-base\",\n                    temperature=0.7,\n                    generation_time_ms=2000.0,\n                    metadata={},\n                    tags=[\"test\"],\n                    created_at=datetime.now()\n                )\n            ]\n            \n            mock_repo.list_records.return_value = mock_records\n            mock_repo_dep.return_value = mock_repo\n            \n            # Test basic listing\n            response = client.get(\"/audio/records\")\n            assert response.status_code == 200\n            \n            result = response.json()\n            assert \"records\" in result\n            assert \"pagination\" in result\n            assert len(result[\"records\"]) == 2\n            \n            # Test with filters\n            response = client.get(\"/audio/records?model_name=nvidia/fugatto-base&limit=1\")\n            assert response.status_code == 200\n            \n            # Verify repository was called with correct parameters\n            mock_repo.list_records.assert_called()\n    \n    def test_get_audio_stats_endpoint(self, client):\n        \"\"\"Test getting audio statistics endpoint.\"\"\"\n        with patch('fugatto_lab.api.routes.audio.get_audio_repository') as mock_repo_dep:\n            # Mock the repository\n            mock_repo = Mock()\n            mock_repo.get_statistics.return_value = {\n                'total_records': 100,\n                'total_duration_hours': 5.5,\n                'average_duration_seconds': 12.0,\n                'average_generation_time_ms': 1500.0\n            }\n            mock_repo.get_aggregated_stats.return_value = {\n                'nvidia/fugatto-base': {\n                    'count': 80,\n                    'avg_duration_seconds': 12.5\n                },\n                'nvidia/fugatto-large': {\n                    'count': 20,\n                    'avg_duration_seconds': 10.0\n                }\n            }\n            mock_repo_dep.return_value = mock_repo\n            \n            response = client.get(\"/audio/stats\")\n            assert response.status_code == 200\n            \n            result = response.json()\n            assert \"overall_statistics\" in result\n            assert \"model_statistics\" in result\n            assert \"recent_activity_7days\" in result\n            assert \"system_info\" in result\n            \n            # Check statistics content\n            overall = result[\"overall_statistics\"]\n            assert overall[\"total_records\"] == 100\n            assert overall[\"total_duration_hours\"] == 5.5\n    \n    def test_download_audio_endpoint(self, client):\n        \"\"\"Test downloading audio files.\"\"\"\n        # Create a mock output file\n        with tempfile.TemporaryDirectory() as temp_dir:\n            output_dir = Path(temp_dir) / \"outputs\" / \"generated\"\n            output_dir.mkdir(parents=True, exist_ok=True)\n            \n            # Create mock audio file\n            test_task_id = \"12345678\"\n            audio_file = output_dir / f\"generated_20250801_120000_{test_task_id}.wav\"\n            \n            # Write minimal WAV content\n            with open(audio_file, 'wb') as f:\n                f.write(b'RIFF\\x24\\x00\\x00\\x00WAVEfmt ')  # Minimal WAV header\n            \n            # Patch Path resolution\n            with patch('fugatto_lab.api.routes.audio.Path') as mock_path:\n                mock_path.return_value = Path(temp_dir)\n                mock_path.side_effect = lambda x: Path(temp_dir) / x if isinstance(x, str) else x\n                \n                # Mock glob to return our test file\n                def mock_glob(pattern):\n                    if test_task_id[:8] in pattern:\n                        return [audio_file]\n                    return []\n                \n                with patch.object(Path, 'glob', mock_glob):\n                    response = client.get(f\"/audio/download/{test_task_id}\")\n                    \n                    assert response.status_code == 200\n                    assert response.headers[\"content-type\"] == \"audio/wav\"\n    \n    def test_error_handling(self, client):\n        \"\"\"Test API error handling.\"\"\"\n        # Test non-existent batch job\n        response = client.get(\"/audio/batch/nonexistent\")\n        assert response.status_code == 404\n        \n        # Test non-existent download\n        response = client.get(\"/audio/download/nonexistent\")\n        assert response.status_code == 404\n        \n        # Test invalid file upload (non-audio file)\n        files = {'audio_file': ('test.txt', io.BytesIO(b'not audio'), 'text/plain')}\n        response = client.post(\"/audio/transform\", files=files, data={'prompt': 'test'})\n        assert response.status_code == 400\n    \n    def test_service_error_propagation(self, client):\n        \"\"\"Test that service errors are properly propagated.\"\"\"\n        with patch('fugatto_lab.api.routes.audio.get_audio_generation_service') as mock_service_dep:\n            # Mock service to raise an exception\n            mock_service = Mock()\n            mock_service.generate_audio.side_effect = Exception(\"Service error\")\n            mock_service_dep.return_value = mock_service\n            \n            with patch('fugatto_lab.api.routes.audio.get_audio_repository') as mock_repo_dep:\n                mock_repo = Mock()\n                mock_repo_dep.return_value = mock_repo\n                \n                request_data = {\n                    \"prompt\": \"Test prompt\",\n                    \"duration_seconds\": 5.0\n                }\n                \n                response = client.post(\"/audio/generate\", json=request_data)\n                assert response.status_code == 500\n                assert \"Service error\" in response.json()[\"detail\"]\n    \n    @pytest.mark.slow\n    def test_concurrent_requests(self, client):\n        \"\"\"Test handling of concurrent API requests.\"\"\"\n        import threading\n        import time\n        \n        results = []\n        errors = []\n        \n        def make_request():\n            try:\n                with patch('fugatto_lab.api.routes.audio.get_audio_generation_service') as mock_service_dep:\n                    mock_service = Mock()\n                    mock_service.generate_audio.return_value = {\n                        'generated_audio': np.random.randn(48000).astype(np.float32),\n                        'duration_seconds': 5.0,\n                        'sample_rate': 48000,\n                        'audio_stats': {}\n                    }\n                    mock_service_dep.return_value = mock_service\n                    \n                    with patch('fugatto_lab.api.routes.audio.get_audio_repository') as mock_repo_dep:\n                        mock_repo = Mock()\n                        mock_repo_dep.return_value = mock_repo\n                        \n                        request_data = {\n                            \"prompt\": f\"Test concurrent request {threading.current_thread().ident}\",\n                            \"duration_seconds\": 5.0,\n                            \"save_output\": False\n                        }\n                        \n                        response = client.post(\"/audio/generate\", json=request_data)\n                        results.append(response.status_code)\n                        \n            except Exception as e:\n                errors.append(str(e))\n        \n        # Create multiple threads\n        threads = []\n        for i in range(5):\n            thread = threading.Thread(target=make_request)\n            threads.append(thread)\n        \n        # Start all threads\n        for thread in threads:\n            thread.start()\n        \n        # Wait for completion\n        for thread in threads:\n            thread.join(timeout=30)  # 30 second timeout\n        \n        # Check results\n        assert len(errors) == 0, f\"Errors occurred: {errors}\"\n        assert len(results) == 5\n        assert all(status == 200 for status in results)\n\n\n@pytest.mark.skipif(not FASTAPI_AVAILABLE, reason=\"FastAPI not available\")\nclass TestAPIConfiguration:\n    \"\"\"Test API configuration and setup.\"\"\"\n    \n    def test_app_creation(self):\n        \"\"\"Test that the application can be created successfully.\"\"\"\n        try:\n            app = create_app()\n            assert app is not None\n            assert app.title == \"Fugatto Audio Lab API\"\n        except ImportError:\n            # Skip if dependencies are missing\n            pytest.skip(\"FastAPI or dependencies not available\")\n    \n    def test_router_inclusion(self):\n        \"\"\"Test that the audio router is properly included.\"\"\"\n        app = FastAPI()\n        app.include_router(audio_router)\n        \n        # Check that routes are registered\n        route_paths = [route.path for route in app.routes]\n        expected_paths = [\n            \"/audio/generate\",\n            \"/audio/transform\",\n            \"/audio/clone\",\n            \"/audio/analyze\",\n            \"/audio/batch\",\n            \"/audio/records\",\n            \"/audio/stats\"\n        ]\n        \n        for path in expected_paths:\n            assert any(path in route_path for route_path in route_paths), f\"Path {path} not found in routes\"\n    \n    def test_openapi_schema_generation(self):\n        \"\"\"Test that OpenAPI schema is generated correctly.\"\"\"\n        app = FastAPI()\n        app.include_router(audio_router)\n        \n        schema = app.openapi()\n        assert \"paths\" in schema\n        assert \"/audio/generate\" in schema[\"paths\"]\n        assert \"components\" in schema\n        assert \"schemas\" in schema[\"components\"]\n        \n        # Check that request/response models are included\n        schemas = schema[\"components\"][\"schemas\"]\n        expected_schemas = [\n            \"AudioGenerationRequest\",\n            \"AudioGenerationResponse\",\n            \"AudioAnalysisResponse\"\n        ]\n        \n        for schema_name in expected_schemas:\n            assert schema_name in schemas, f\"Schema {schema_name} not found\"\n\n\n# Cleanup function to remove temporary files\ndef pytest_runtest_teardown(item):\n    \"\"\"Clean up temporary files after tests.\"\"\"\n    import tempfile\n    import shutil\n    \n    # Clean up any temporary directories created during tests\n    temp_dirs = ['temp', 'outputs']\n    for temp_dir in temp_dirs:\n        if Path(temp_dir).exists():\n            try:\n                shutil.rmtree(temp_dir)\n            except:\n                pass  # Ignore errors during cleanup